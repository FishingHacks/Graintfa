import chalk from 'chalk';
import cors from 'cors';
import { app, BrowserWindow, dialog } from 'electron';
import express from 'express';
import fs from 'fs';
import { JsonDB } from 'node-json-db';
import { Config } from 'node-json-db/dist/lib/JsonDBConfig';
import { setFilePath, setRPC, setState, setUnknown } from './lib/rpc';
// This allows TypeScript to pick up the magic constant that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;

const log = console.log;
const db = new JsonDB(new Config('userData', true, false, '/'));

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
	// eslint-disable-line global-require
	app.quit();
}

let win: BrowserWindow;

const createWindow = (): void => {
	// Create the browser window.
	win = new BrowserWindow({
		minHeight: 600,
		minWidth: 800,
		backgroundColor: '#1f2937',
		webPreferences: {
			webSecurity: false,
		},
		frame: false,
		roundedCorners: true,
	});

	win.maximize();
	win.show();

	// and load the index.html of the app.
	win.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);
};

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on('ready', createWindow);

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', () => {
	if (process.platform !== 'darwin') {
		app.quit();
	}
});

app.on('activate', () => {
	// On OS X it's common to re-create a window in the app when the
	// dock icon is clicked and there are no other windows open.
	if (BrowserWindow.getAllWindows().length === 0) {
		createWindow();
		setRPC({
			largeImageKey: 'graintfa',
			largeImageText: 'Graintfa',
		});
	}
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.

type Field = {
	x: number;
	y: number;
	name: string;
	selected: boolean;
	highlighted: boolean;
	id: number;
	size: number;
	image?: {
		opacity: number;
		path: string;
		saturation: boolean;
	};
};

const server = express();

server.use(cors());

server.get('/program/close', (req, res) => {
	app.quit();
	res.status(200);
});
server.get('/program/maximize', (req, res) => {
	if (win.isMaximized()) win.unmaximize();
	else win.maximize();
	res.status(200);
});
server.get('/program/minimize', (req, res) => {
	win.minimize();
	res.status(200);
});

server.post('/save', async (req, res) => {
	const { fields: f, fieldindex: fi, filepath: fn } = req.headers;
	const fields: Field[] = JSON.parse(Array.isArray(f) ? f[0] : f);
	const fieldIndex: number = parseInt(Array.isArray(fi) ? fi[0] : fi);
	let filePath: string = Array.isArray(fn) ? fn[0] : fn;

	if (!filePath || filePath == undefined || filePath == 'undefined') {
		filePath = await dialog.showSaveDialogSync(win, {
			buttonLabel: 'Save',
			title: 'Save GUI',
			filters: [
				{
					extensions: ['rgraintf'],
					name: 'Graintfa file',
				},
			],
			properties: ['showOverwriteConfirmation'],
		});
	}

	await fs.writeFileSync(
		filePath,
		JSON.stringify({
			fieldIndex: fieldIndex,
			fields: fields,
		}),
	);

	res.status(200).json({ filePath });

	await addRecent(filePath);

	setFilePath(filePath);
});

server.get('/open', async (req, res) => {
	let filePath: string[] = Array.isArray(req.headers.filepath)
		? req.headers.filepath
		: [req.headers.filepath];
	if (!filePath || filePath.includes('undefined'))
		filePath = await dialog.showOpenDialogSync(win, {
			buttonLabel: 'Open',
			title: 'Open a GUI',
			filters: [
				{
					extensions: ['rgraintf'],
					name: 'Graintfa file',
				},
			],
			properties: ['openFile'],
		});

	const content = await fs.readFileSync(filePath[0], { encoding: 'utf8' });

	const parsedContent: {
		fieldIndex: number;
		fields: Field[];
	} = JSON.parse(content);

	res.status(200).json({ ...parsedContent, filePath: filePath[0] });

	await addRecent(filePath[0]);

	setFilePath(filePath[0]);
});

server.get('/openItemTexture', async (req, res) => {
	const filePath = await dialog.showOpenDialogSync(win, {
		buttonLabel: 'Load',
		title: 'Item texture',
		filters: [
			{
				extensions: ['png'],
				name: 'Minecraft texture file',
			},
		],
		properties: ['openFile'],
	});

	res.status(200).json({ filePath });
});

server.get('/image/:path', async (req, res) => {
	const img = await fs.readFileSync(req.params.path).toString('base64');
	res.send(img);
});

server.get('/editor', (req, res) => {
	setUnknown();
	res.status(200);
});

server.get('/recent', async (req, res) => {
	let recent: string[] = [];
	try {
		recent = await db.getData('/recent');
	} catch (err) {
		recent = [];
		await db.push('/recent', []);
	}

	res.json(recent).status(200);

	setState('In the main menu');
});

server.get('/recent/clear', async (req, res) => {
	await db.push('/recent', []);
	res.status(200);
});

const defaultSettings = [
	{
		path: '/settings/theme',
		value: 'dark',
	},
	{
		path: '/settings/keepNavOpen',
		value: true,
	},
];

server.get('/settings', async (req, res) => {
	defaultSettings.forEach(async (s) => {
		if (!db.exists(s.path)) await db.push(s.path, s.value);
	});
	const d = await db.getData('/settings');

	res.status(200).json(d);
});

server.post('/settings', async (req, res) => {
	const s = JSON.parse(
		Array.isArray(req.headers.settings)
			? req.headers.settings[0]
			: req.headers.settings,
	);
	db.push('/settings', s);
	res.status(200);
});

server.get('/theme', async (req, res) => {
	if (!db.exists('/settings/theme')) await db.push('/settings/theme', 'dark');
	const theme = await db.getData('/settings/theme');

	res.status(200).json(theme);
});

async function addRecent(filePath: string) {
	let recent: string[] = [];
	try {
		recent = await db.getData('/recent');
	} catch (err) {
		recent = [];
		await db.push('/recent', []);
	}

	if (recent.includes(filePath)) {
		recent.splice(recent.indexOf(filePath[0]), 1);
	}

	recent.push(filePath);

	await db.push('/recent', recent);
}

server.listen(736, () => {
	log(chalk.green('[SERVER]: Listening on port 736!'));
});
